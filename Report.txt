YAMTORRENT - Python BitTorrent Client
CPSC 433: Computer Networks Final Project
by: David Hergenroeder (david.hergenroeder@yale.edu)
    Micah Rosales (micah.rosales@yale.edu)
    Lincoln Swaine-Moore (lincoln.swaine-moore@yale.edu)

+------------+
| BACKGROUND |
+------------+

Background on the BitTorrent Protocol

    BitTorrent is a peer-to-peer Internet file sharing protocol that 
was designed by Bram Cohen in 2001. It has enjoyed widespread success 
and adoption and is currently one of the most common protocols for 
peer-to-peer transfer of large files.

    A BitTorrent downloads a file by joining a "swarm" of hosts that 
are downloading and uploading the file simultaneously. This is 
advantageous over other traditional client/server file transfer 
protocols, especially for large files that are downloaded many times,
because it more efficiently distributes the work of uploading.

    A torrent is created by creating a .torrent file, which contains
metadata that describe the file or files that make up the torrent, 
such as the url of the tracker, the creation date, the size of the 
file, the piece length, the number of pieces that make up the file,
and a 20-byte SHA1 hash for each piece of the file.

    The tracker is a host that maintains and makes available a list of
peers for the torrent. When a BitTorrent client wants to download a
file, they obtain the .torrent file, and issue a GET request to the
tracker. The tracker responds with list of peers. The client can then
begin to communicate with the peers directly to begin to download the
file.

    Peer-to-peer communication is done in BitTorrent via the following
protocol. 





+---------------------+
| YAMTORRENT OVERVIEW |
+---------------------+

An Overview of our BitTorrent Client 

	Our client can be run with the command "python3 YamTorrent.py 
<*.torrent>". It is important to use Python 3 when running the client
because some dependencies require Python 3, as does some of the syntax
used in the code written here. 

	YamTorrent first scans the .torrent file in the TorrentMetadata
for important information, such as the tracker URL (currently we only 
support HTTP), the number of pieces, and the "info" section about the file 
to be download, from which a sha1 hash is computed. YamTorrent then 
contacts the tracker in the TrackerConnection class whose URL was 
found in the torrent file with a GET request using that info hash
as one of several parameters. Also sent is a peer id that the client
wishes to be known as, the amount the client has left to download of the 
file (initially, all of it), and a flag that tells the tracker it wants
the returned information to be "compact" (this seems to be standard
practice).

	When the tracker responds to this GET requests, it is with information
about peers to which the client can potentially connect. At this point,
there is a callback to the TorrenManager's class, and the TorrentManager
can begin to initiate connections with as many of those peers as it 
choosees.

	A connection to a peer is managed by the PeerConnection class, 
which first initiates a handshake with the peer, after which (hopefully)
that peer sends along a bitfield, which allows the client to see
which pieces are available for request. The PeerConnection then listens
for an "unchoke" message from the peer, at which point it changes its 
state to reflect that it can now send messages. The TorrentManager
maintains a list of the peers it has connected to, and scans it regularly
for peer connections that are both idle (not currently requesting 
anything from a peer) and unchoked. It then searches the bitfield of that
PeerConnection for a piece to request (doing so in order of priority of
pieces). If it finds one it would like, it instructs the PeerConnection
to start downloading that piece. There is a callback for when the Peer
Connection completes downloading that piece that stores in the Torrent
Manager's bitfield that it now has the piece, and seeks to the appropriate
offset of a file to write that piece.

	The actual downloading of the piece is managed by the PeerConnection,
which sends an interested, and then sends a request for the first block.
When a block is received, it stores it and initiates the request for the 
block. It does so until all the blocks have been receives, at which point
it has a callback to the TorrentManager.

	This process continues until the whole of the file has been downloaded.


+----------------+
| DESIGN CHOICES |
+----------------+

Particular Design Choices We Made

Twisted

	This was one of the most important design choices we made. Via the
recommendation of a blog post, we found this library, which enables 
relatively easy asynchronous programming in Python. We used the 
twisted to enable multiple peer connections to be operating independently
and at their own pace, without opening multiple threads. Twisted permits
callbacks that enable the TorrentManager to be notified when important 
events occur at the PeerConnection level, such as a bitfield is received
or a piece finishes downloading.

Buffer

	Messages from peers can arrive in any number of packets, which is why
the length header of a message is so important. No message should be read
until the entirety of its length has arrived. To managed this aspect, we
employed a buffer that was simply a bytearray. Whenever a new message
arrives from a peer, it is appended to the buffer, and the front of the 
buffer is checked to see the length of the first message that was in there.
If the whole is present, the PeerConnectoin processes that message as is
appropriate to its type, and checks to see if there are any more complete 
messages in the buffer. The buffer thus offers the PeerConnection a
simulation of the messages arriving as complete and distinct entities, 
when in reality, they are split piecemeal across many packets.

Download pieces in order

	The TorrentManager maintains a list of pieces it desires in order.
For every idle and unchoked peer found in a regular sweep of the peers,
the TorrentManager looks through its desired pieces in order, and sees 
whether the peer has that piece. If it does, it removes the piece from 
the list, and tells the piece to start downloading. Currently the list 
is in order from first piece to last piece. While not every peer will 
have every piece, and so the downloading may occur slightly out of order,
having the desired order be linear with the actual order is both simple
and useful. In the event of say, streaming, it is useful to have earlier 
pieces arrive earlier, so the file can be played faster.

+--------------+
| Dependencies |
+--------------+

We used the following modules:

sys
requests
hashlib
bencodepy
struct
socket
os
bitstring
twisted
enum
urllib
glob

Most of these should be available through any standard distribution,
and any that are not (e.g. twisted, bencodepy, etc.) are available
via pip.

+-----------------------+
| POSSIBLE IMPROVEMENTS |
+-----------------------+

Areas for Future Improvement / Possible Future Features

- torrents with multiple files
- supporting udp trackers
- pausing and later restarting torrents
- creating torrents

